<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="对象模型," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="执行期语意学(Runtime Semantics)">
<meta name="keywords" content="对象模型">
<meta property="og:type" content="article">
<meta property="og:title" content="深入探索C++对象模型(六)">
<meta property="og:url" content="http://yoursite.com/2017/06/12/深入探索C-对象模型-六/index.html">
<meta property="og:site_name" content="越努力 | 越幸运">
<meta property="og:description" content="执行期语意学(Runtime Semantics)">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170612111549118-1101890222.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170612111612603-1319939788.png">
<meta property="og:updated_time" content="2017-06-12T03:20:20.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入探索C++对象模型(六)">
<meta name="twitter:description" content="执行期语意学(Runtime Semantics)">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170612111549118-1101890222.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/12/深入探索C-对象模型-六/"/>





  <title>深入探索C++对象模型(六) | 越努力 | 越幸运</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">越努力 | 越幸运</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/深入探索C-对象模型-六/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Lai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="越努力 | 越幸运">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入探索C++对象模型(六)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T11:18:30+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="执行期语意学-Runtime-Semantics"><a href="#执行期语意学-Runtime-Semantics" class="headerlink" title="执行期语意学(Runtime Semantics)"></a>执行期语意学(Runtime Semantics)</h2><a id="more"></a>
<h3 id="对象的构造和析构-Object-Constructor-and-Destructor"><a href="#对象的构造和析构-Object-Constructor-and-Destructor" class="headerlink" title="对象的构造和析构(Object Constructor and Destructor)"></a>对象的构造和析构(Object Constructor and Destructor)</h3><p>一般而言，constructor和destructor的安插都如你所预期：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    Point point;</div><div class="line">    <span class="comment">//point.Point::Point()  一般而言会被安插在这里</span></div><div class="line">    ...</div><div class="line">    <span class="comment">//point.Point::~Point() 一般而言会被安插在这里</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果一个区段(译注：以{}括起来的区域)或函数中有一个以上的离开点，情况会稍微混乱一些。Destructor必须被放在每一个离开点(当时object还存活)之前。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    Point point;</div><div class="line">    <span class="comment">//constructor在这里行动</span></div><div class="line">    <span class="keyword">switch</span>(<span class="keyword">int</span>(point.x()))&#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">-1</span> : </div><div class="line">            <span class="comment">//mumble;</span></div><div class="line">            <span class="comment">//destructor在这里行动</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">            <span class="comment">//mumble</span></div><div class="line">            <span class="comment">//destructor在这里行动</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">//mumble</span></div><div class="line">            <span class="comment">//destructor在这里行动</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//destructor在这里行动</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般而言我们会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。</p>
<h4 id="全局对象-Global-Objects"><a href="#全局对象-Global-Objects" class="headerlink" title="全局对象(Global Objects)"></a>全局对象(Global Objects)</h4><p>如果我们有以下程序片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Matrix identity;</div><div class="line"></div><div class="line">main()&#123;</div><div class="line">    <span class="comment">//identity必须在此处被初始化</span></div><div class="line">    Matrix m1 = identity;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++ 保证，一定会在main()函数中第一次用到identity之前，把identity构造出来，而在main()函数结束之前把identity摧毁掉。像identity这样的所谓global object如果有constructor和destructor的话，我们说它需要静态的初始化操作和内存释放操作。</p>
<p>C++程序中所有的global objects都被放置在程序的data segment中。如果显式指定给它一个值，此object将以该值为初值。否则object配置到的内存内容为0。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> v1 = <span class="number">1024</span>;</div><div class="line"><span class="keyword">int</span> v2;</div></pre></td></tr></table></figure></p>
<p>v1和v2都被配置于程序的data segment，v1值为1024，v2值为0(这和C略有不同，C并不设定初值)。在C语言中一个global object只能够被一个常量表达式(可在编译期求其值的那种)设定初值。当然，constructor并不是常量表达式。虽然class object在编译时期可以被放置于data segment中并且内容为0，但constructor一直要到程序启动(startup)时才会实施。必须对一个“放置于program data segment中的object的初始化表达式”做评估(evaluate)，这正是为什么一个object需要静态初始化的原因。</p>
<p>当cfront还是唯一的C++编译器，而且跨平台移植性比效率的考虑更重要的时候，有一个可移植但成本颇高的静态初始化(以及内存释放)方法，我把它成为munch。其策略如下：</p>
<ol>
<li><p>为每一个需要静态初始化的档案产生一个_ sti()函数，内带必要的constructor调用操作或inline expansions。例如前面所说的identity对象会在matrix.c中产生出下面的_sti()函数(sti就是static initialization的缩写)：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_sti_matrix_c_identity()&#123;</div><div class="line">    identity.Matrix::Matrix();  </div><div class="line">    initialization;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类似情况，在每一个需要静态的内存释放操作(static deallocation)的文件，产生一个<em>std()函数(static deallocation)，内带必要的destructor操作，或是其inline expansions。在我们的例子中会有一个</em> std()函数被产生出来，针对identity对象调用Matrix destructor。</p>
</li>
<li>提供一组runtime library “munch”函数：一个_main()函数(用以调用可执行文件中的所有 _sti()函数)，以及一个exit(函数)(以类似方法调用所有的 _std()函数)。</li>
</ol>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170612111549118-1101890222.png" alt=""></p>
<p>以一个derived class的pointer或reference来存取virtual base class subobject，是一种nonconstant expression，必须在执行期才能加以评估求值。例如，尽管下列程序片段在编译时期可知：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//constant expression</span></div><div class="line">Vertex3d *pv = <span class="keyword">new</span> PVertex;</div><div class="line">Point3d *p3d = pv;</div></pre></td></tr></table></figure></p>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170612111612603-1319939788.png" alt=""></p>
<p>其virtual base class Point的subobject在每一个derived class中的位置却可能会变动，因此不能够在编译时期设定下来，下面的初始化操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Point是Point3d的一个virtual base class</span></div><div class="line"><span class="comment">//pt的初始化操作需要某种形式的执行期评估(runtime evaluation)</span></div><div class="line">Point *pt = p3d;</div></pre></td></tr></table></figure></p>
<p>需要编译器提供内部扩充，以支持class object的静态初始化(至少涵盖class objects的指针和references)，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Initial support of virtual base class conversion requires</span></div><div class="line"><span class="comment">//non-constant initialization support</span></div><div class="line">Point *pt = p3d-&gt;vbcPoint;</div></pre></td></tr></table></figure></p>
<p>使用被静态初始化的objects有一些缺点，例如，如果exception handling被支持，那些objects将不能够被放置于try区段之内。这对于被静态调用的constructors可能是特别无法接受的，因为任何的throw操作将必然触发exception handling library默认的terminate()函数。另一个缺点是为了控制”需要跨越模块做静态初始化”objects的相依顺序而扯出来的复杂度。</p>
<h4 id="局部静态对象-Local-Static-Objects"><a href="#局部静态对象-Local-Static-Objects" class="headerlink" title="局部静态对象(Local Static Objects)"></a>局部静态对象(Local Static Objects)</h4><p>假设有如下程序片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> Matrix&amp; <span class="title">identity</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Matrix mat_identity;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> mat_identity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Local static class objects保证了什么样的语意？</p>
<ul>
<li>mat_identity的constructor必须只能施行一次，虽然上述函数可能会被调用多次。</li>
<li>mat_identity的destructor必须只能施行一次，虽然上述函数可能会被调用多次。</li>
</ul>
<p>编译器的策略之一就是，无条件地在程序起始(startup)时构造出对象来。然而这会导致所有的local static class objects都在程序起始时被初始化，即使它们所在的那个函数从不曾被调用过。因此，只在identity()函数被调用时才把mat_identity构造起来，是比较好的做法(现在的C++ Standard已经强制要求这一点)。那我们应该怎么做呢？</p>
<p>cfront之中的做法是：首先，导入一个临时性对象以保护mat_identity的初始化操作。第一次处理identity时，这个临时性对象被评估为false，于是constructor会被调用，然后临时性对象被改写为true。这样就解决了构造的问题。而在相反的一端，destructor也需要有条件施行于 mat_identity是否被构造起来，很简单，如果那个临时性对象为true，就表示构造好了。困难的是，由于cfront产生C码，mat_identity对函数而言仍然是local，因此我没办法在静态的内存释放函数(static deallocation function)中存取它。解决办法是：取出local object的地址。(当然，由于object是static，其地址再downstream compoent中被转换到程序内用来放置global object的data segment中)。下面是cfront的输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//被产生出来的临时对象，作为戒护之用</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Matrix</span> *_0_<span class="title">F3</span> = 0;</span></div><div class="line"></div><div class="line"><span class="comment">//C++的reference在C中是以pointer来代替identity()的名称会被mangled</span></div><div class="line"><span class="function">struct Matrix* <span class="title">identity_Fv</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> _1<span class="title">mat_identity</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">//如果临时性的保护对象已被设立，那就什么也别做，否则</span></div><div class="line">    <span class="comment">//调用constructor: _ct_6MatrixFv</span></div><div class="line">    <span class="comment">//设定保护对象，使它指向目标对象</span></div><div class="line">    _0_F3 </div><div class="line">     ？ <span class="number">0</span> ： (_ct_6MatrixFv(&amp; _1mat_identity), </div><div class="line">            (_0_F3 = (&amp;_lmat_identity)));</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，destructor必须在”与text program file(也就是本例中的stat_0.c)有关了的静态内存释放函数(static deallocation function)”中被有条件的调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> _std_stat_0_c()&#123;</div><div class="line">    _0_F3 ? _dt_6MatrixFv(_0_F3, <span class="number">2</span>) : <span class="number">0</span> ;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请记住，指针的使用时cfront所特有的；然而条件式解构则是所有编译器都需要的。</p>
<h4 id="对象数组-Array-of-Objects"><a href="#对象数组-Array-of-Objects" class="headerlink" title="对象数组(Array of Objects)"></a>对象数组(Array of Objects)</h4><p>假设有以下的数组定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<p>需要完成什么东西呢？ 如果Point既没有定义一个constructor也没有定义一个destructor，那么我们的工作不会比建立一个”内建(build-in)类型所组成的数组”更多，也就是说，我们只需配置足够的内存以存储10个连续的Point元素。</p>
<p>然而Point的确定义了一个default destructor，所以这个destructor必须轮流施行于每一个元素之上。一般而言这是经由一个或多个runtime library函数达成。在cfront中，我们使用一个被命名为vec_new()函数，产生出以class objects构造而成的数组。比较晚近的编译器，包括Borland/Microsoft/Sun，则是提供两个函数，一个用以处理“没有virtual base class”的class，另一个用来处理“内带virtual base class”的class。后一个函数通常被称为vec_vnew()。函数类型通常如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void* vec_new(</div><div class="line">    void* array,    //数组起始地址</div><div class="line">    size_t elem_size,  //每一个class object的大小</div><div class="line">    int elem_count,    //数组中的元素数目</div><div class="line">    void (*constructor)(void*) ,</div><div class="line">    void (*destructor)(void*, char)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>其中的constructor和destructor参数是这个class的default constructor和default destructor的函数指针。参数array带有的若不是具名数组(本例为knots)的地址，就是0。如果是0，那么数组将经由应用程序的new运算符，被动态配置于heap中。</p>
<p>在vec_new()中，constructor施行于elem_count个元素之上。对于支持exception handling的编译器而言，destructor的提供是必要的。下面是编译器可能针对我们的10个Point元素所做的vec_new()调用操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>];</div><div class="line">vec_new(&amp;knots, <span class="keyword">sizeof</span>(Point), <span class="number">10</span>, &amp;Point::Point, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>如果Point也定义了一个destructor，当knots的生命结束时，该destructor也必须施行于那10个Point元素身上。这也是经由一个类似的vec_delete()(或是vec_vdelete()——如果classes拥有virtual base classes的话)的runtime library函数完成，其函数原型如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *vec_delete(</div><div class="line">    void *array,     //数组起始地址</div><div class="line">    size_t elem_size,    //每一个class object的大小</div><div class="line">    int elem_count,      //数组中的元素数目</div><div class="line">    void (*destructor)(void*, char) </div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>有些编译器会另外增加一些参数，用以传递其它数值，以便能够有条件地导引vec_delete()逻辑，在vec_delete()中，destructor被施行于elem_count个元素身上。</p>
<p>如下例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>] = &#123;</div><div class="line">    Point(),</div><div class="line">    Point(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),</div><div class="line">    <span class="number">-1.0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对于那些明显获得初值的元素，vec_new()不再有必要。对于那些尚未被初始化的元素，vec_new()的施行方式就像面对“由class elements组成的数组，而该数组没有explicit initialization list”一样，因此上一个定义很可能被转换为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Point knots[<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="comment">//明确初始化前3个元素</span></div><div class="line">Point::Point(&amp;knots[<span class="number">0</span>]);</div><div class="line">Point::Point(&amp;knots[<span class="number">1</span>], <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>);</div><div class="line">Point::Point(&amp;knots[<span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</div><div class="line"></div><div class="line"><span class="comment">//以vec_new初始化后7个元素</span></div><div class="line">vec_new(&amp;knots + <span class="number">3</span>, <span class="keyword">sizeof</span>(Point), <span class="number">7</span>, &amp;Point::Point, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<h3 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h3><p>运算符new的使用，看起来似乎是个单一运算，像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>但事实上它由以下两个步骤完成：</p>
<ol>
<li><p>通过适当的new运算符函数实体，配置所需的内存：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用函数库中的new运算符</span></div><div class="line"><span class="keyword">int</span> *pi = _new(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div></pre></td></tr></table></figure>
</li>
<li><p>给配置得来的对象设立初值：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*pi = <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p> 更进一步地，初始化操作应该在内存配置成功(经由new运算符)后才执行：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new运算符的两个分离步骤</span></div><div class="line"><span class="comment">//given: int *pi = new int(5)</span></div><div class="line"></div><div class="line"><span class="comment">//重写声明</span></div><div class="line"><span class="keyword">int</span> *pi;</div><div class="line"><span class="keyword">if</span>(pi = _new(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</div><div class="line">    *pi = <span class="number">5</span>;  <span class="comment">//成功了才初始化</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>delete运算符的情况类似。当程序员写下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> pi;</div></pre></td></tr></table></figure></p>
<p>时，如果pi的值是0，C++ 语言会要求delete运算符不要有操作。因此编译器必须为此调用构造一层保护膜：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(pi != <span class="number">0</span>)</div><div class="line">    _delete(pi);</div></pre></td></tr></table></figure></p>
<p>请注意pi并不会因此被自动清除为0。所以后续的pi的任何操作是没有定义的。这是因为对于pi所指向之内存的变更或再使用，可能发生也可能不发生。</p>
<p>以constructor来配置一个class object，情况类似。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point3d *origin = <span class="keyword">new</span> Point3d;</div></pre></td></tr></table></figure></p>
<p>被转换为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point3d *origin;</div><div class="line"><span class="keyword">if</span>(origin  = _new(<span class="keyword">sizeof</span>(Point3d)))</div><div class="line">    origin = Point3d::Point3d(origin);</div></pre></td></tr></table></figure></p>
<p>一般的library对于new运算符的实现操作都很直接了当，但有两个精巧之处值得斟酌。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">void</span> *last_alloc;</div><div class="line">    <span class="keyword">while</span>(!(last_alloc = <span class="built_in">malloc</span>(size)))&#123;</div><div class="line">        <span class="keyword">if</span>(_new_handler)</div><div class="line">            (*_new_handler)();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> last_alloc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然这样写是合法的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> T[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<p>但语言要求每一次对new的调用都必须传回一个独一无二的指针。解决该问题的传统方法是传回一个指针，指向一个默认为1-byte的内存区块(这就是为什么吧size设为1的原因)。这个实现技术的另一个有趣之处是，它允许使用者提供一个属于自己的_new_handler()函数。这正是为什么每一次循环都调用_new_handler()之故。</p>
<p>new运算符实际上总是以标准的C malloc()完成，虽然并没有规定一定得这么做不可。相同情况，delete运算符总是以标准的C free()完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(ptr)</div><div class="line">        <span class="built_in">free</span>((<span class="keyword">char</span>*)ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="针对数组的new语意"><a href="#针对数组的new语意" class="headerlink" title="针对数组的new语意"></a>针对数组的new语意</h4><p>当我们这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<p>时，vec_new()不会真正被调用，因为它的主要功能是把default constructor施行于class objects所组成的数组的每一个元素身上。倒是new运算符会被调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p_array = (<span class="keyword">int</span>*)_new(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div></pre></td></tr></table></figure></p>
<p>相同情况下，如果我们写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//struct simple_aggr &#123; float f1, f2; &#125;</span></div><div class="line">simple_aggr *p_aggr = <span class="keyword">new</span> simple_aggr[<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<p>vec_new()也不会被调用，为什么？因为simple_aggr并没有定义一个constructor或destructor，所以配置数组以及清除p_aggr数组的操作，只是单纯地获得内存和释放内存而已，这些操作由new和delete运算符来完成就绰绰有余了。</p>
<p>然而如果class定义有一个default constructo，某些版本的vec_new()就会被调用，配置并构造class objects所组成的数组。例如这个算式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point3d *p_array = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<p>通常会被编译为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point3d *p_array;</div><div class="line">p_array = vec_new(<span class="number">0</span>, <span class="keyword">sizeof</span>(Point3d), <span class="number">10</span>, </div><div class="line">                &amp;Point3d::Point3d, &amp;Point3d::~Point3d);</div></pre></td></tr></table></figure></p>
<p>在个别的数组元素构造过程中，如果发生exception，destructor就会被传递给vec_new()，只有已经构造妥当的元素才需要destructor的施行，因为它们的内存已经被配置出来了，vec_new()有责任在exception发生时把那些内存释放掉。</p>
<p>寻找数组维度，对于delete运算符的效率带来极大的冲击，所以才导致这样的妥协：只有在中括号出现时，编译器才寻找数组的维度，否则它便假设只有单独一个objects要被删除。如果程序员没有提供必须的中括号，像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> p_array;</div></pre></td></tr></table></figure></p>
<p>那么就只有第一个元素会被解析，其他的元素仍然存在——虽然相关的内存已经被要求归还了。</p>
<h4 id="Placement-Operator-new的语意"><a href="#Placement-Operator-new的语意" class="headerlink" title="Placement Operator new的语意"></a>Placement Operator new的语意</h4><p>有一个预先定义好的重载的(overloaded) new运算符，称为placement operator new，它需要第二个参数，类型为void*，调用方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point2w *ptw = <span class="keyword">new</span>(arena) Point2w;</div></pre></td></tr></table></figure></p>
<p>其中arena指向内存中的一个区块，用以放置新产生出来的Point2w object。这个预先定义好的placement operator new的实现方法简直是出乎意料的平凡，它只要将“获得的指针”(上例为arena)所指的地址传回即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">void</span> *p)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，以上只是真正所发生的操作的一半而已。另外一半无法由程序员产生出来。想想这些问题：</p>
<ol>
<li>什么是使placement new operator能够有效运行的另一半部扩充(而且是”arena的明确指定操作”所没有提供的)</li>
<li>什么是arena的真正类型？该类型暗示了什么？</li>
</ol>
<p>Placement new operator所扩充的另一半边是将Point2w constructor自动实施于arena所指的地址上：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point2w *ptw = (Point2w*)arena;</div><div class="line"><span class="keyword">if</span>(pt2 != <span class="number">0</span>)</div><div class="line">    ptw-&gt;Point2w::Point2w();</div></pre></td></tr></table></figure></p>
<p>这正是使placement operator new威力如此强大的原因。这一份码决定objects被配置在哪里；编译系统保证object的constructor会施行于其上。</p>
<p>另一个问题关系到arena所表现的真正指针类型。C++ Standard说它必须指向相同类型的class，要不就是一块”新鲜”内存，足够容纳该类型的object。注意，derived class很明显并不在被支持之列。对于一个derived class，或是其他没有关联的类型，其行为虽然并非不合法，却也未经定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//新鲜的存储空间可以这样配置而来</div><div class="line">char *arena = new char[sizeof(Point2w)];</div><div class="line"></div><div class="line">//相同类型的object可以这样获得</div><div class="line">Point2w *arena = new Point2w;</div></pre></td></tr></table></figure></p>
<p>不论哪一种情况，新的Point2w的存储空间的确是覆盖了arena的位置，而此行为已在良好控制之下。然而，一般而言，placement new operator并不支持多态(polymorphism)。被交给new的指针，应该适当地指向一块预先配置好的内存。如果derived class比其base class大，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point2w *p2w = <span class="keyword">new</span>(arena) Point3w;</div></pre></td></tr></table></figure></p>
<p>Point3w的constructor将会导致严重的破坏。</p>
<h3 id="临时性对象-Temporary-Objects"><a href="#临时性对象-Temporary-Objects" class="headerlink" title="临时性对象(Temporary Objects)"></a>临时性对象(Temporary Objects)</h3><p>如果我们有一个函数，形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</div></pre></td></tr></table></figure></p>
<p>以及两个T objects，a和b，那么:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a + b;</div></pre></td></tr></table></figure></p>
<p>可能会导致一个临时性对象，以放置传回的对象。是否会导致一个临时性对象，视编译器的进取性(aggressiveness)以及上述操作发生时的程序上下关系而定。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T a, b;</div><div class="line">T c = a + b;</div></pre></td></tr></table></figure></p>
<p>编译器会产生一个临时性对象，放置 a+b的结果，然后再使用T的copy constructor，把该临时性对象当作 c 的初值。然而比较更可能的转换是直接以拷贝构造的方式，将 a+b的值放到c中。于是就不需要临时性对象，以及对其constructor和destructor的调用了。</p>
<p>临时性对象的被摧毁，应该是对完整表达式(full-expression)求值过程中的最后一个步骤。该完整表达式造成临时对象的产生。</p>
<p>什么是一个完整表达式(full-expression)？非正式地说，它是被涵括的表达式中最外围的那个。下面这个式子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//tertiary full expression with 5 sub-expressions</span></div><div class="line">((objA &gt; <span class="number">1024</span>) &amp;&amp; (objB &gt; <span class="number">1024</span>) ? objA + objB : foo(objA, objB));</div></pre></td></tr></table></figure></p>
<p>一个有五个子算式，内带一个”? : 完整表达式”中。任何一个子表达式所产生的任何一个临时对象，都应该在完整表达式被求值完成后，才可以毁去。</p>
<p>当临时性对象是根据程序的执行期语意有条件地产生出来时，临时性对象的生命规则就显得有些复杂了。举个例子，像这样的表达式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s + t || u + v)</div></pre></td></tr></table></figure></p>
<p>其中u+v 子算式只有在s+t 被评估为false时，才会开始被评估。与第二个子算式有关的临时性对象必须被摧毁。但是，很明显地，不可以无条件地摧毁，也就是说，我们希望只有在临时性对象被产生出来的情况下才去催毁它。</p>
<p>临时性对象的生命规则有两个例外。第一个例外发生在表达式被用来初始化一个object时，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> verbase;</div><div class="line">...</div><div class="line">String progNameVersion = !verbase ? <span class="number">0</span> : progName + progVersion;</div></pre></td></tr></table></figure></p>
<p>其中progName和progVersion都是String objects。这时候会生出一个临时对象，放置加法运算符的运算结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp;, <span class="keyword">const</span> String&amp;);</div></pre></td></tr></table></figure></p>
<p>临时对象必须根据对verbase的测试结果有条件地解构。在临时对象的生命规则之下，它应该在完整表达的”? : 表达式”结束评估之后尽快地被摧毁。然而，如果progNameVersion的初始化需要调用一个copy constructor：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">progNameVersion.String::String(tmp);</div></pre></td></tr></table></figure></p>
<p>那么临时性对象的解构(在”? : 完整表达式”之后)当然就不是我们所期望的。C++ Standard要求说：凡含有表达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。</p>
<p>临时性对象的生命规则的第二个例外是”当一个临时性对象被一个reference绑定”时，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> String &amp;space = <span class="string">" "</span>;</div></pre></td></tr></table></figure></p>
<p>产生出这样的程序代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String tmp;</div><div class="line">tmp.String::String(<span class="string">" "</span>);</div><div class="line"><span class="keyword">const</span> String &amp;space = tmp;</div></pre></td></tr></table></figure></p>
<p>如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之reference的生命结束，或直到临时对象的生命范畴(scope)结束——视哪一种情况先到达而定。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/对象模型/" rel="tag"># 对象模型</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/09/深入探索C-对象模型-五/" rel="next" title="深入探索C++对象模型(五)">
                <i class="fa fa-chevron-left"></i> 深入探索C++对象模型(五)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/13/深入探索C-对象模型-七/" rel="prev" title="深入探索C++对象模型(七)">
                深入探索C++对象模型(七) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jeff Lai" />
          <p class="site-author-name" itemprop="name">Jeff Lai</p>
           
              <p class="site-description motion-element" itemprop="description">原来你是我最想留住的幸运</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lengender" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2664793953/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#执行期语意学-Runtime-Semantics"><span class="nav-number">1.</span> <span class="nav-text">执行期语意学(Runtime Semantics)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的构造和析构-Object-Constructor-and-Destructor"><span class="nav-number">1.1.</span> <span class="nav-text">对象的构造和析构(Object Constructor and Destructor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局对象-Global-Objects"><span class="nav-number">1.1.1.</span> <span class="nav-text">全局对象(Global Objects)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部静态对象-Local-Static-Objects"><span class="nav-number">1.1.2.</span> <span class="nav-text">局部静态对象(Local Static Objects)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象数组-Array-of-Objects"><span class="nav-number">1.1.3.</span> <span class="nav-text">对象数组(Array of Objects)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new和delete运算符"><span class="nav-number">1.2.</span> <span class="nav-text">new和delete运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#针对数组的new语意"><span class="nav-number">1.2.1.</span> <span class="nav-text">针对数组的new语意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Placement-Operator-new的语意"><span class="nav-number">1.2.2.</span> <span class="nav-text">Placement Operator new的语意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临时性对象-Temporary-Objects"><span class="nav-number">1.3.</span> <span class="nav-text">临时性对象(Temporary Objects)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Lai</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
