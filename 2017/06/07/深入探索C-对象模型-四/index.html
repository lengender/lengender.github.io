<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="对象模型," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="Function语意学(The Semantics of Function)">
<meta name="keywords" content="对象模型">
<meta property="og:type" content="article">
<meta property="og:title" content="深入探索C++对象模型(四)">
<meta property="og:url" content="http://yoursite.com/2017/06/07/深入探索C-对象模型-四/index.html">
<meta property="og:site_name" content="越努力 | 越幸运">
<meta property="og:description" content="Function语意学(The Semantics of Function)">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607213930668-1870839334.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607213952340-1392813239.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607214015856-693193969.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607214039293-1820373768.png">
<meta property="og:updated_time" content="2017-06-07T13:49:05.691Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入探索C++对象模型(四)">
<meta name="twitter:description" content="Function语意学(The Semantics of Function)">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607213930668-1870839334.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/07/深入探索C-对象模型-四/"/>





  <title>深入探索C++对象模型(四) | 越努力 | 越幸运</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">越努力 | 越幸运</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/07/深入探索C-对象模型-四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Lai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="越努力 | 越幸运">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入探索C++对象模型(四)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-07T21:47:28+08:00">
                2017-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Function语意学-The-Semantics-of-Function"><a href="#Function语意学-The-Semantics-of-Function" class="headerlink" title="Function语意学(The Semantics of Function)"></a>Function语意学(The Semantics of Function)</h2><a id="more"></a>
<p>static member functions不可能做到的两点：(1)直接存取nonstatic数据，(2)被声明为const的。</p>
<h3 id="Member的各种调用方式"><a href="#Member的各种调用方式" class="headerlink" title="Member的各种调用方式"></a>Member的各种调用方式</h3><h4 id="Nonstatic-Member-Functions-非静态成员函数"><a href="#Nonstatic-Member-Functions-非静态成员函数" class="headerlink" title="Nonstatic Member Functions(非静态成员函数)"></a>Nonstatic Member Functions(非静态成员函数)</h4><p>C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。比如，要在下面两个函数之间作选择：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">magnitude3d</span><span class="params">(<span class="keyword">const</span> Point3d *_this)</span></span>&#123; ... &#125;</div><div class="line"><span class="keyword">float</span> Point3d::magnitude3d() <span class="keyword">const</span> &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>选择member function不应该带来什么额外负担。这是因为编译器内部已将“member函数实例”转换为对等的“nonmember函数实例”</p>
<p>下面是magnitude()的一个nonmember定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">magnitude3d</span><span class="params">(<span class="keyword">const</span> Point3d *_this)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>( _this-&gt;_x * _this-&gt;_x +</div><div class="line">                 _this-&gt;_y * _this-&gt;_y +</div><div class="line">                 _this-&gt;_z * _this-&gt;_z );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>乍见之下似乎nonmember function比较没有效率，它间接地经由参数取用坐标成员，而member function却是直接取用坐标成员，然而实际上member function被内化为nonmember的形式。 转化步骤如下：</p>
<ol>
<li>改写函数的signature(译注：意指函数原型)以安插一个额外的参数到member function中，用以提供一个存取管道，使class object得以将此函数调用。该额外参数被称为this指针。</li>
<li>将每一个“对nonstatic data member的存取操作”改为经由this指针来存取。</li>
<li>将member function重新写成一个外部函数。将函数名称经过“mangling”处理，使它在程序中称为独一无二的词汇。</li>
</ol>
<h4 id="名称的特殊处理-Name-Mangling"><a href="#名称的特殊处理-Name-Mangling" class="headerlink" title="名称的特殊处理(Name Mangling)"></a>名称的特殊处理(Name Mangling)</h4><p>一般而言，member的名称前面会加上class的名称，形成独一无二的命名。例如下面的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> ival; ... &#125;;</div></pre></td></tr></table></figure></p>
<p>其中的<code>ival</code>有可能变成这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//member经过name-mangling之后的可能结果之一</span></div><div class="line">ival_3Bar</div></pre></td></tr></table></figure></p>
<p>为什么编译器要这么做？请考虑如下派生操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span>  Bar&#123; <span class="keyword">public</span>: <span class="keyword">int</span> ival; ... &#125;</div></pre></td></tr></table></figure></p>
<p>记住，Foo对象内部结合了base class和derived class两者：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Foo的内部描述</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> ival_3Bar;</div><div class="line">    <span class="keyword">int</span> ival_3Foo;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>不管你要处理哪一个<code>ival</code>，通过”name mangling”，都可以绝对清楚地指出来。由于member function可以被重载化(overload)，所以需要更广泛的mangling手法，以提供绝对独一无二的名称。</p>
<p>把参数和函数名称编码在一起，编译器是在不同的编译模块之间达成了一种有限形式的类型检验。举例如下，如果一个print函数被这样定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Point3d&amp; )</span></span>&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>但意外地被这样声明和调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以为是const Point3d&amp;</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Point3d )</span></span>;</div></pre></td></tr></table></figure></p>
<p>两个实体如果拥有独一无二的name mangling，那么任何不正确的调用操作在链接时期就因无法决议(resolved)而失败。有时候我们可以乐观地称此为“确保类型安全的链接行为”(type-safe linkage)。我说“乐观地”是因为它可以捕捉函数标记(signature，亦即函数名称+参数数目 + 参数类型)错误；如果“返回类型”声明错误，就没有办法检查出来。</p>
<h4 id="Virtual-Member-Functions-虚拟成员函数"><a href="#Virtual-Member-Functions-虚拟成员函数" class="headerlink" title="Virtual Member Functions(虚拟成员函数)"></a>Virtual Member Functions(虚拟成员函数)</h4><p>如果normalize()是一个virtual member function，那么以下调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;normalize();</div></pre></td></tr></table></figure></p>
<p>将会被内部转化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( *ptr-&gt;vptr[<span class="number">1</span>])(ptr);</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>vptr表示由编译器产生的指针，指向virtual table。它被安插在每一个”声明有(或继承自)一个或多个virtual functions”的class object中。事实上其名称也会被”mangled”，因为在一个复杂的class派生体系中，可能存在有多个vptrs</li>
<li>1 是virtual tabel slot的索引值，关联到normalize()函数</li>
<li>第二个ptr表示this指针</li>
</ul>
<h4 id="Static-Member-Functions-静态成员函数"><a href="#Static-Member-Functions-静态成员函数" class="headerlink" title="Static Member Functions(静态成员函数)"></a>Static Member Functions(静态成员函数)</h4><p>如果Point3d::normalize()是一个static member function，以下两个调用操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.normalize();</div><div class="line">ptr-&gt;normalize();</div></pre></td></tr></table></figure></p>
<p>将被转换为一般的nonmember函数调用，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//obj.normalize()</span></div><div class="line">normalize_7Point3dSFv();</div><div class="line"><span class="comment">//ptr-&gt;normalize()</span></div><div class="line">normalize_7Point3dSFv();</div></pre></td></tr></table></figure></p>
<p>在引入static member functions之前，C++ 语言要求所有的member functions都必须经由该class的object来调用。而实际上，只有当一个或多个nonstatic data members在member function中被直接存取时，才需要class object。class object提供了this指针给这种形式的函数调用使用。这个this指针把“在member function中存取的nonstatic class members”绑定于“object内对应的members”之上。如果没有任何一个members被直接存取，事实上就不需要this指针，因此也就没有必要通过一个class object来调用一个member function。不过，C++ 语言到当前为止并不能识别这种情况。</p>
<p>static member functions的主要特性是它没有this指针。以下的次要特性统统根源于其主要特性：</p>
<ul>
<li>它不能够直接存取其class中的nonstatic members</li>
<li>它不能够被声明为const、volatile或virtual</li>
<li>它不需要经由class object才被调用，虽然大部分时候它是这样被调用的。<br><br></li>
</ul>
<p>如果取一个static member function的地址，获得的将是其在内存中的位置，也就是其地址。由于static member function没有this指针，所以其地址的类型并不是一个“指向class member of function的指针”，而是一个“nonmember函数指针”。</p>
<h3 id="Virtual-Member-Functions-虚拟成员函数-1"><a href="#Virtual-Member-Functions-虚拟成员函数-1" class="headerlink" title="Virtual Member Functions(虚拟成员函数)"></a>Virtual Member Functions(虚拟成员函数)</h3><p>virtual function的一般实现模型：每一个class有一个virtual table，内含该class之中有作用的virtual function的地址，然后每个object有一个vptr，指向virtual table的所在。</p>
<p>为了支持virtual function机制，必须首先能够对于多态对象有某种形式的“执行期类型判断法(runtime type resolution)”。也就是说，以下的调用操作将需要ptr在执行期的某些相关信息，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;z();</div></pre></td></tr></table></figure></p>
<p>如此一来才能够找到并调用z()的适当实体。</p>
<p>在C++中，多态(polymorphism)表示“以一个public base class的指针(或reference)，寻址出一个derived class object”的意思。例如下面的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point *ptr;</div></pre></td></tr></table></figure></p>
<p>我们可以指定ptr以寻址出一个Point2d对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptr = <span class="keyword">new</span> Point2d;</div></pre></td></tr></table></figure></p>
<p>或是一个Point3d对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptr = <span class="keyword">new</span> Point3d;</div></pre></td></tr></table></figure></p>
<p>ptr的多态机能主要扮演一个输送机制(transport mechanism)的角色，经由它，我们可以在程序的任何地方采用一组public derived类型，这种多态形式被称为消极的(passive)，可以在编译期完成——virtual base class的情况除外。</p>
<p>当被指出的对象真正被使用时，多态也就变成积极的(active)了。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//积极多态的常见例子</span></div><div class="line">ptr-&gt;z();</div></pre></td></tr></table></figure></p>
<p>在runtime type identification(RTTI)性质于1993年被引入C++ 语言之前，C++ 对“积极多态”的唯一支持，就是对virtual function call的决议(resolution)操作。有了RTTI，就能够在执行期查询一个多态的指针或多态的reference了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//积极多态的第二个例子</span></div><div class="line"><span class="keyword">if</span>(Point3d *p3d = <span class="keyword">dynamic_cast</span>&lt;Point3d*&gt;(ptr))</div><div class="line">    <span class="keyword">return</span> p3d-&gt;_z;</div></pre></td></tr></table></figure></p>
<p>在实现上，可以在每一个多态对象的class object身上增加两个members:</p>
<ol>
<li>一个字符串或数字，表示class的类型</li>
<li>一个指针，指向表格，表格中带有程序的virtual function的执行期地址</li>
</ol>
<p>表格中的virtual functions地址如何被构建起来？在C++ 中，virtual function(可经由其class object被调用)可以在编译时期获知。此外，这一组地址是固定不变的。执行期不可能新增或替换之。由于程序执行时，表格的大小和内容都不会改变，所以其建构和存取皆可以由编译器完全掌控，不需要执行期的任何介入。</p>
<p>一个class只会有一个virtual table，每一个table内含其对应的class object中所有active virtual functions函数实例的地址。这些active virtual functions包括：</p>
<ul>
<li>这一class所定义的函数实例。它会改写(overriding)一个可能存在的base class virtual function函数实例。</li>
<li>继承自base class的函数实例。这是在derived class决定不改写virtual function时才会出现的情况</li>
<li>一个pure_virtual_called()函数实例，它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数(有时候会用到)</li>
</ul>
<p>每一个virtual function都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的virtual function的关系。如下的Point class体系中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Point();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _x; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>);</div><div class="line">    <span class="keyword">float</span> _x;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>vitual destructo被赋值slot 1。而mult()被赋值slot 2。mult()并没有函数定义(因为它是一个pure virtual function)，所以pure_virtual_calssed()的函数地址会被放在slot 2中，如果该函数意外地被调用，通常的操作是结束掉这个程序。y()被赋值slot 3而z()被赋值slot 4。下图为Point的内存布局和virtual table。</p>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607213930668-1870839334.png" alt=""></p>
<h4 id="单一继承下的Virtual-Functions"><a href="#单一继承下的Virtual-Functions" class="headerlink" title="单一继承下的Virtual Functions"></a>单一继承下的Virtual Functions</h4><p>当一个class派生自Point时，会发生什么事情？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> :</span> <span class="keyword">public</span>  Point&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point2d(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>)</div><div class="line">        : Point(x), _y(y) &#123; &#125;</div><div class="line">    ~Point2d();</div><div class="line">    </div><div class="line">    <span class="comment">//改写base class virtual functions</span></div><div class="line">    <span class="function">Point2d &amp;<span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _y ;&#125;</div><div class="line">    <span class="comment">//... 其他操作</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> _y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一共有三种可能性：</p>
<ol>
<li>它可以继承base class所声明的virtual function的函数实体。正确地说，是该函数实体得地址会被拷贝到derived class的virtual table的相对应的slot之中</li>
<li>它可以实现自己的函数实体，表示它自己的函数实体地址必须放在对应的slot中</li>
<li>它可以加入一个新的virtual function。这时候virtual table的尺寸会增大一个slot，而新的函数实体地址被放进该slot中</li>
</ol>
<p>类似的情况如下，Point3d派生自Point2d：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point3d(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>)</div><div class="line">        : Point2d(x, y), _z(z)&#123; &#125;</div><div class="line">    ~Point3d();</div><div class="line">    </div><div class="line">    <span class="comment">//改写base class virtual functions</span></div><div class="line">    <span class="function">Point3d &amp;<span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> _z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其virtual table中的slot 1 放置Point3d destructor，slot 2放置Point3d::mult()。slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z() 函数地址。Point2d，Point3d的对象布局和virtual table如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607213952340-1392813239.png" alt=""></p>
<p>在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承中，对virtual function的支持就没有那么美好了。</p>
<h4 id="多重继承下的Virtual-Functions"><a href="#多重继承下的Virtual-Functions" class="headerlink" title="多重继承下的Virtual Functions"></a>多重继承下的Virtual Functions</h4><p>在多重继承中支持virtual functions，其复杂读围绕在第二个及后继的base classes身上，以及“必须在执行期调整this指针”这一点。以下面的class体系为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base1();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Base1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speakClearly</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> data_Base1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base2();</div><div class="line">    <span class="keyword">virtual</span> ~Base2();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> data_Base2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Derived();</div><div class="line">    <span class="keyword">virtual</span> ~Derived();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> data_Derived;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Derived 支持virtual functions的困难度，统统落在Base2 subobject身上。有三个问题需要解决，以此而言分别是(1)virtual destructor,(2)被继承下来的Base2::mumble(),(3)一组clone()函数实体。</p>
<p>首先，把一个从heap中配置而得的Derived对象的地址，指定给一个Base2指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</div></pre></td></tr></table></figure></p>
<p>新的Derived对象的地址必须调整，以指向其Base2 subobject。编译时期会产生以下的码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//转移以支持第二个base class</span></div><div class="line">Derived *tmp = <span class="keyword">new</span> Derived;</div><div class="line">Base2 *pbase2 = tmp ? tmp + <span class="keyword">sizeof</span>(Base1) : <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>如果没有这样的调整，指针的任何“非多态运用”都将失败：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//即使pbase2被指定一个Derived对象，这也应该没有问题</span></div><div class="line">pbase2-&gt;data_Base2;</div></pre></td></tr></table></figure></p>
<p>当程序员要删除pbase2所指的对象时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//必须首先调用正确的virtual destructor函数实体</span></div><div class="line"><span class="comment">//然后施行delete运算符</span></div><div class="line"><span class="comment">//pbase2可能需要调整，以指出完整对象的起始点</span></div><div class="line"><span class="keyword">delete</span> pbase2;</div></pre></td></tr></table></figure></p>
<p>指针必须被再一次调整，以求再一次指向Derived对象的起始处(推测它还指向Derived对象)。然而上述的offset加法却不能够在编译时期直接设定，因为pbase2所指的真正对象只有在执行期才能确定。</p>
<p>一般规则是，经由指向“第二或后继之base class”的指针(或reference)来调用derived class virtual function。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</div><div class="line">...</div><div class="line"><span class="keyword">delete</span> pbase2; <span class="comment">//invoke derived class's destructor(virtual)</span></div></pre></td></tr></table></figure></p>
<p>该调用操作所连带的“必要的this指针调整”操作，必须在执行期完成。也就是说，offset的大小，以及把offset加到this指针上头的那一小段程序代码，必须经由编译器在某个地方插入。</p>
<p>比较有效率的解决办法是利用所谓的thunk。所谓thunk是以小段assembly代码，用来(1)以适当的offset值调整this指针，(2)调到virtual function去。例如，经由一个Base2指针用Derived destructor，其相关的thunk可能看起来是这个样子的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pbase2_dtor_thunk:</div><div class="line">    <span class="keyword">this</span> += <span class="keyword">sizeof</span>(base1);</div><div class="line">    Derived::~Derived(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>Thunk技术允许virtual table slot继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。Slots中的地址可以直接指向virtual function，也可以指向一个相关的thunk(如果需要调整this指针的话)。于是，对于那些不需要调整this指针的virtual function而言，也就不需承载效率上的额外负担。</p>
<p>调整this指针的第二个额外负担就是，由于两个不同的可能：(1)经由derived class(或第一个base class)调用，(2)经由第二个(或其后继)base class调用，同一函数在virtual table中可能需要多笔对应的slots。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Base1 *pbase1 = <span class="keyword">new</span> Derived;</div><div class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</div><div class="line"></div><div class="line"><span class="keyword">delete</span> pbase1;</div><div class="line"><span class="keyword">delete</span> pabse2;</div></pre></td></tr></table></figure></p>
<p>虽然两个delete操作导致相同的Derived destructor，但它们需要两个不同的virtual table slots:</p>
<ol>
<li>pbase1不需要调整this指针(因为Base1是最左端base class之故，它已经指向Derived 对象的起始处)，其virtual table slot需放置真正的destructor地址。</li>
<li>pbase2需要调整this指针，其virtual table slot需要相关的thunk地址<br><br></li>
</ol>
<p>在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的个数(因此，单一继承将不会有额外的virtual tables)。</p>
<p>针对每一个virtual tables，Derived对象中有对应的vptr。下图说明了这点，vptrs将在constructor(s)中被设定初值(经由编译器所产生的码)</p>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607214015856-693193969.png" alt=""></p>
<p>用以支持“一个class拥有多个virtual tables”的传统方法是，将每一个tables以外部对象的形式产生出来，并给予独一无二的名称。例如，Derived所关联的两个tables可能有这样的名称：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vtbl_Derived;   <span class="comment">//主要表格</span></div><div class="line">vtbl_Base2_Derived;   <span class="comment">//次要表格</span></div></pre></td></tr></table></figure></p>
<p>于是当你将一个Derived对象地址指定给一个Base1指针或Derived指针时，被处理的virtual table是主要表格vtbl_Derived。而当你将一个Derived对象地址指定给一个Base2指针时，被处理的virtual table是次要表格vtbl_Base2_Derived。</p>
<p>由于执行期链接器(runtime linkers)的降临(可以支持动态共享函数库)，符号名称的链接变得非常缓慢。为了调节执行期链接器的效率，Sun编译器将多个virtual tables连锁为一个；指向次要表格的指针，可由主要表格名称加上一个offset获得。在这样的策略下，每一个class只有一个具名的virtual table。</p>
<p><strong>有以下三种情况，第二或后继的base class会影响对virtual functions的支持。</strong></p>
<ol>
<li>第一种情况是，通过一个”指向第二个base class”的指针，调用derived class virtual function。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</div><div class="line"></div><div class="line"><span class="comment">//调用Derived::~Derived</span></div><div class="line"><span class="comment">//ptr必须向后调整sizeof(Base1)个bytes</span></div><div class="line"><span class="keyword">delete</span> ptr;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>从上面那个图可以看到这个调用操作的重点：ptr指向Derived对象中的Base2 subobject；为了能够正确执行，ptr必须调整指向Derived对象的起始处。</p>
<ol>
<li><p>第二种情况是第一种情况的变化，通过一个“指向derived class”的指针，调用第二个base class中一个继承而来的virtual function。在此情况下，derived class指针必须再次调整，以指向第二个base subobject。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Derived *pder = <span class="keyword">new</span> Derived;</div><div class="line"></div><div class="line"><span class="comment">//调用Base2::mumble()</span></div><div class="line"><span class="comment">//pder必须被向前调整sizeof(Base1)个bytes</span></div><div class="line">pder-&gt;mumble();</div></pre></td></tr></table></figure>
</li>
<li><p>第三种情况发生于一个语言扩充性质之下：允许一个virtual function的返回值类型有所变化，可能是base type，也可能是publicly derived type。这一点可以通过Derived::clone()函数实体来说明。clone()的Derived版本传回一个Derived class指针，默默地改写了它的两个base class的函数实体。当我们通过“指向第二个base class”的指针来调用clone()时，this指针的offset问题于是诞生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</div><div class="line"></div><div class="line"><span class="comment">//调用Derived * Derived::clone()</span></div><div class="line"><span class="comment">//返回值必须被调整，指向Base2 subobject</span></div><div class="line">Base2 *pb2 = pb1-&gt;clone();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当进行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址，于是clone()的Derived版会被调用；它会传回一个指针，指向一个新的Derived对象，该对象的地址在被指定给pb2之前，必须先经过调整，以指向Base2 subobject。</p>
<h4 id="虚拟继承下的Virtual-Functions"><a href="#虚拟继承下的Virtual-Functions" class="headerlink" title="虚拟继承下的Virtual Functions"></a>虚拟继承下的Virtual Functions</h4><p>考虑下面的virtual base class派生体系，从Point2d派生出Point3d:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point2d(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</div><div class="line">    <span class="keyword">virtual</span> ~Point2d();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> _x, _y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Point3d(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</div><div class="line">    ~Point3d();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">float</span> _z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其内存布局如下图：</p>
<p><img src="http://images2015.cnblogs.com/blog/1122912/201706/1122912-20170607214039293-1820373768.png" alt=""></p>
<p>当一个virtual base class从另一个virtual base class派生而来，并且两者都支持virtual functions和nonstatic data members时，编译器对于virtual base class的支持简直就像进了迷宫一样。建议不要在一个virtual base class中声明nonstatic data members。</p>
<h3 id="指向Member-Function指针-Pointer-to-Member-Functions"><a href="#指向Member-Function指针-Pointer-to-Member-Functions" class="headerlink" title="指向Member Function指针(Pointer-to-Member Functions)"></a>指向Member Function指针(Pointer-to-Member Functions)</h3><p>取一个nonstatic data member的地址，得到的结果是该member在class布局中bytes位置(再加1)。可以想象，它是一个不完整的值，它需要被绑定于某个class object的地址上，才能够被存取</p>
<p>取一个nonstatic data member的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。然而这个值也是不完全的。它也需要被绑定于某个class object的地址上，才能够通过它调用该函数。所有的nonstatic member functions都需要对象的地址(以参数this指出)</p>
<p>一个指向member fucntion的指针，其声明语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span>           <span class="comment">//return type</span></div><div class="line">( Point::*       <span class="comment">//class the function is member</span></div><div class="line">   pmf)          <span class="comment">//name of pointer to member</span></div><div class="line">  ();            <span class="comment">//argument list</span></div></pre></td></tr></table></figure></p>
<p>然后我们可以这样定义并初始化该指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> (Point::*coord)() = &amp;Point::x;</div></pre></td></tr></table></figure></p>
<p>也可以这样指定其值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">coord = &amp;Point::y;</div></pre></td></tr></table></figure></p>
<p>想要调用它，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(origin.*coord)();</div><div class="line">或</div><div class="line">(ptr-&gt;*corrd)();</div></pre></td></tr></table></figure></p>
<p>这些操作会被编译器转化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(coord)(&amp;origin);</div><div class="line">和</div><div class="line">(coord)(ptr);</div></pre></td></tr></table></figure></p>
<p>指向member function的指针的声明语法，以及指向“member selection运算符”的指针，其作用是作为this指针的空间保留着。这也就是为什么static member functions(没有this指针)的类型是“函数指针”，而不是“指向member function的指针”之故。</p>
<p>使用一个“member function指针”，如果并不用于virtual function、多重继承、virtual base class等情况的话，并不会比使用一个“nonmember function指针”的成本高</p>
<h4 id="支持“指向Virtual-Member-Function”的指针"><a href="#支持“指向Virtual-Member-Function”的指针" class="headerlink" title="支持“指向Virtual Member Function”的指针"></a>支持“指向Virtual Member Function”的指针</h4><p>注意下面的程序片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> (Point::*pmf)() = &amp;Point::z;</div><div class="line">Point *ptr = <span class="keyword">new</span> Point3d;</div></pre></td></tr></table></figure></p>
<p>pmf，一个指向member function的指针，被设值为Point::z() (一个virtual function)的地址。ptr则被指定以一个Point3d对象，如果我们经由ptr调用z():<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;z();</div></pre></td></tr></table></figure></p>
<p>则被调用的是Point3d::z()。同样，我们可以从pmf间接调用z()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(ptr-&gt;*pmf)();</div></pre></td></tr></table></figure></p>
<p>也就是说，虚拟机制仍然能够在使用”指向memeber function之指针”的情况下运行。</p>
<p>对一个nonstatic member function取其地址，将获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，所能知道的仅是virtual function在其相关之virtual table之中的索引值。也就是说，<strong>对一个virtual member function取其地址，所能获得的只是一个索引值。</strong></p>
<p>例如：假设我们有以下的Point声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Point();</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后取其destructor的地址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;Point::~Point</div></pre></td></tr></table></figure></p>
<p>得到的结果是 1， 取x()或y()的地址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&amp;Point::x();</div><div class="line">&amp;Point::y();</div></pre></td></tr></table></figure></p>
<p>得到的则是函数在内存中的地址，因为它们不是virtual。取z()的地址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;Point::z();</div></pre></td></tr></table></figure></p>
<p>得到的结果是2。通过pmf来调用z()，会被内部转化为一个编译时期的式子，一般形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf])(ptr);</div></pre></td></tr></table></figure></p>
<p>对一个“指向member function的指针”评估求值，会因为改制有两种意义而复杂化；其调用操作也将有别于常规的调用操作。集编译器必须定义函数指针使它能够(1)含有两种数值,(2)更重要的是其数值可以被区别代表内存地址还是virtual table中的索引值。</p>
<h4 id="在多重继承下，指向Member-Functions的指针"><a href="#在多重继承下，指向Member-Functions的指针" class="headerlink" title="在多重继承下，指向Member Functions的指针"></a>在多重继承下，指向Member Functions的指针</h4><p>为了让指向member functions的指针也能够支持多重继承和虚拟继承，Stroustrup设计了下面一个结构体：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一般结构，用以支持在多重继承之下指向member functions的指针</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">mptr</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> delta;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">union</span>&#123;</div><div class="line">        protofunc faddr;</div><div class="line">        <span class="keyword">int</span> v_offset;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>它们要表现什么呢？index和faddr分别(不同时)带有virtual table索引和nonvirtual member function地址(为了方便，当index不指向virtual table时，会被设为-1)。在该模型下，像这样的调用操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(ptr-&gt;*pmf)();</div></pre></td></tr></table></figure></p>
<p>会变成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(pmf.index &lt; <span class="number">0</span>) </div><div class="line">   ?    <span class="comment">//non-virtual invocation</span></div><div class="line">   ( *pmf.faddr )( ptr)</div><div class="line">   :   <span class="comment">//virtual invocation</span></div><div class="line">   (* ptr-&gt;vptr[pmf.index](ptr));</div></pre></td></tr></table></figure></p>
<p>这种方法所受的批评是：每一个调用操作都得付出上述成本，检查其是否为virtual或nonvirtual。Microsoft把这项检查拿掉，导入一个它所谓的vcall thunk。在此策略下，faddr被指定的要不就是真正的member function(如果函数是nonvirtual的话)，要不就是vcall thunk的地址。于是virtual或nonvirtual函数的调用操作透明化，vcall thunk会选出并调用相关virtual table中适当的slot。</p>
<p>delta字段表示this指针的offset值，而v_offset字段放的是一个virtual(或多重继承中的第二或后继的)base class的vptr位置。如果vptr被编译器放在class对象的起头处。这个字段就没有必要了，代价则是C对象兼容性降低。这些字段只在多重继承或虚拟继承的情况下才有其必要性，有许多编译器在自身内部根据不同的classes特性提供多种指向member functions的指针形式，例如Microsoft就供应了三种风味：</p>
<ol>
<li>一个单一继承实例(其中带有vcall thunk地址或是函数地址)</li>
<li>一个多重继承实例(其中带有faddr和delta两个members)</li>
<li>一个虚拟继承实例(其中带有四个members)</li>
</ol>
<h3 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h3><p>一般而言，处理一个inline函数，有两个阶段：</p>
<ol>
<li>分析函数定义，以决定函数的“intrinsic inlin ability”(本质的inline能力)。“intrinsic”(本质的，固有的)一词在这里意指“与编译器相关”</li>
</ol>
<p>如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个static函数，并在“被编译模块”内产生对应的函数语义。</p>
<ol>
<li>真正的inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作(evaluation)以及临时性对象的管理。</li>
</ol>
<p>同样在扩展点上，编译器将决定这个调用是否“不可为inline”。</p>
<h4 id="形式参数-Formal-Arguments"><a href="#形式参数-Formal-Arguments" class="headerlink" title="形式参数(Formal Arguments)"></a>形式参数(Formal Arguments)</h4><p>一般而言，面对“会带来副作用的实际参数”，通常都需要引入临时性对象。换句话说，如果实际参数时一个常量表达式(constant expression)，我们可以在替换之前先完成其求值操作(evaluations)；后继的inline替换，就可以把常量直接“绑”上去。如果既不是常量表达式，也不是带有副作用的表达式，那么就直接替换之。<br>举例如下，假设我们有以下的简单inline函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是三个调用操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> minval;</div><div class="line">    <span class="keyword">int</span> val1 = <span class="number">1024</span>;</div><div class="line">    <span class="keyword">int</span> val2 = <span class="number">2048</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/*(1)*/</span> minval = min(val1, val2);</div><div class="line">    <span class="comment">/*(2)*/</span> minval = min(<span class="number">1024</span>, <span class="number">2048</span>);</div><div class="line">    <span class="comment">/*(3)*/</span> minval = min(foo(), bar() + <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> minval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>标识为(1)的那一行会被扩展为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = val1 &lt; val2 ? val1 : val2;</div></pre></td></tr></table></figure></p>
<p>标识为(2)的那一行直接拥抱常量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = <span class="number">1024</span>;</div></pre></td></tr></table></figure></p>
<p>标识为(3)的那一行则引发参数的副作用，它需要导入一个临时对象，以避免重复求值(multiple evaluations)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> t1;</div><div class="line"><span class="keyword">int</span> t2;</div><div class="line">minval = (t1 = foo()), (t2 = bar() + <span class="number">1</span>),</div><div class="line">        t1 &lt; t2 ? t1 : t2;</div></pre></td></tr></table></figure></p>
<h4 id="局部变量-Local-Variables"><a href="#局部变量-Local-Variables" class="headerlink" title="局部变量(Local Variables)"></a>局部变量(Local Variables)</h4><p>一般而言，inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。如果inline函数以单一表达式(expression)扩展多次，则每次扩展都需要自己的一组局部变量。如果inline函数以分离的多个式子(discrete statements)被扩展多次，那么只需一组局部变量，就可以重复使用(译注：因为它们被放在一个封闭区段中，有自己的scope)</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/对象模型/" rel="tag"># 对象模型</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/06/83-Remove-Duplicates-from-Sorted-List/" rel="next" title="83. Remove Duplicates from Sorted List">
                <i class="fa fa-chevron-left"></i> 83. Remove Duplicates from Sorted List
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/09/深入探索C-对象模型-五/" rel="prev" title="深入探索C++对象模型(五)">
                深入探索C++对象模型(五) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jeff Lai" />
          <p class="site-author-name" itemprop="name">Jeff Lai</p>
           
              <p class="site-description motion-element" itemprop="description">原来你是我最想留住的幸运</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">84</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lengender" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2664793953/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Function语意学-The-Semantics-of-Function"><span class="nav-number">1.</span> <span class="nav-text">Function语意学(The Semantics of Function)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Member的各种调用方式"><span class="nav-number">1.1.</span> <span class="nav-text">Member的各种调用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nonstatic-Member-Functions-非静态成员函数"><span class="nav-number">1.1.1.</span> <span class="nav-text">Nonstatic Member Functions(非静态成员函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#名称的特殊处理-Name-Mangling"><span class="nav-number">1.1.2.</span> <span class="nav-text">名称的特殊处理(Name Mangling)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Virtual-Member-Functions-虚拟成员函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">Virtual Member Functions(虚拟成员函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Static-Member-Functions-静态成员函数"><span class="nav-number">1.1.4.</span> <span class="nav-text">Static Member Functions(静态成员函数)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-Member-Functions-虚拟成员函数-1"><span class="nav-number">1.2.</span> <span class="nav-text">Virtual Member Functions(虚拟成员函数)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单一继承下的Virtual-Functions"><span class="nav-number">1.2.1.</span> <span class="nav-text">单一继承下的Virtual Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多重继承下的Virtual-Functions"><span class="nav-number">1.2.2.</span> <span class="nav-text">多重继承下的Virtual Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟继承下的Virtual-Functions"><span class="nav-number">1.2.3.</span> <span class="nav-text">虚拟继承下的Virtual Functions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向Member-Function指针-Pointer-to-Member-Functions"><span class="nav-number">1.3.</span> <span class="nav-text">指向Member Function指针(Pointer-to-Member Functions)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#支持“指向Virtual-Member-Function”的指针"><span class="nav-number">1.3.1.</span> <span class="nav-text">支持“指向Virtual Member Function”的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在多重继承下，指向Member-Functions的指针"><span class="nav-number">1.3.2.</span> <span class="nav-text">在多重继承下，指向Member Functions的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-Functions"><span class="nav-number">1.4.</span> <span class="nav-text">Inline Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#形式参数-Formal-Arguments"><span class="nav-number">1.4.1.</span> <span class="nav-text">形式参数(Formal Arguments)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量-Local-Variables"><span class="nav-number">1.4.2.</span> <span class="nav-text">局部变量(Local Variables)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Lai</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
